- 만일 두번째, 세번째 제네릭이 필요하다면 S, U 로 이어나간다.
- 명명하고 싶은 대로 아무 단어나 넣어도 문제는 없지만
대중적으로 통상적인 네이밍이 있으면 개발이 용이해지기 때문에
암묵적인 규칙이 존재한다.

<T>	타입(TYPE)
<E>	요소(Element)
<K>	키(Key)
<V>	값(Value)
<N>	숫자(Number)

List컬렉션

- 배열과 유사한 자료구조로 중복이 허용되면서 저장순서가 유지 되는 구조를 제공
- 배열처럼 index를 사용해 데이터를 저장하고 찾게된다.
- 단, 배열과는 다르게 크기의 제한이 없으며 삽입, 삭제, 변경의 기능이 자유롭다.
- 데이터의 크기를 특정할 수 없는 다량의 데이터를 저장할 때 용이하게 사용할 수 있다.

List에서 제공하는 주요 메서드

void add(E e)		삽입		데이터를 순차적으로 삽입
void add(int index, E e) 	중간삽입		원하는 index 위치에 삽입
void set(int index, E e)	치환		원하는 index 위치에 값 변경
E get(int index)		반환		선택된 index 위치에 값 반환
void remove(int index)	삭제		선택된 index 위치의 값 삭제
void clear()		전체삭제		모든 데이터 삭제
int size()			크기		저장된 데이터의 개수 반환
boolean contains(Object o)	검색		데이터 존재 여부 확인

ArrayList
가장 많이 사용하는 List 인터페이스의 대표적인 구현 클래스이다.
JDK 1.2부터 제공된 ArrayList는 내부적으로 배열을 이용해 구현되어 배열과 호환성이 좋은 자료구조이다.

List<데이터타입> list = new ArrayList<데이터타입>();

JDK 1.7 이후부터는 Collection의 선언이 간소화되었다.

List<데이터타입> list = new ArrayList<>();

회원정보를 저장

ArrayList<String> name = new ArrayList<>();
ArrayList<Integer> age = new ArrayList<>();
ArrayList<String> address = new ArrayList<>();


고객의 인적사항을 추가하고, 삭제하고, 확인하기 위한 문제출제.

이름과 나이, 번호를 갖는 Person클래스를 만든 후, ArrayList를 사용하여
아래의 결과처럼 Person객체의 정보추가와 전체정보 보기를 할 수 있도록 만들어보자  
아래의 기능은 PersonManger클래스에서 personMgr()메서드를 통해 만든다.

결과 : 
1. 정보추가
2. 정보삭제
3. 전체정보
4. 종료
항목선택 : 1 <- 정보추가 항목
-----정보추가-----
이름 : 1
나이 : 1
전화 : 1
정보가 저장되었습니다.

1. 정보추가
2. 정보삭제
3. 전체정보
4. 종료
항목선택 : 3 <- 정보보기 항목
----전체정보----
등록인원 1명
이름 : 1
나이 : 1
전화 : 1


Set
- List 와는 달리 객체의 저장 순서를 보장하지 않는다.
- Set 컬렉션은 수학의 집합과 유사한 개념을 지니고 있다.
- List 컬렉션은 저장시 중복을 허용하지만 Set 컬렉션은 데이터의 중복을 허용하지 않는다.
- 데이터를 저장할 대 순서, 즉 index를 부여하지 않기 때문에 데이터가 입력된 순서대로 출력된다는 보장이 없다.

Set인터페이스에서 제공하는 메서드
void add(E e)		데이터를 순차적으로 삽입
void remove(Object o)	선택된 값 삭제
void clear()		모든 데이터 삭제
int size()			저장된 데이터의 개수 반환
boolean contains(Object o)	데이터 존재 여부 확인

HashSet
- Set인터페이스에서 가장 많이 사용되는 클래스로 인터페이스를 상속받아 구현된다.


반복자(Iterator)
- Iterator는 List컬렉션에서 제공하는 인터페이스로 사전적인 의미로는
'반복하다'라는 뜻을 지니고 있다.
- List 컬렉션의 요소를 순회하여 하나씩 추출하는데 사용한다.
- 반복자라고도 불리는 Iterator 객체는 선언된 컬렉션 객체에서 가져와 사용된다.

Iterator 메서드
boolean hasNext()		다음에 순회할 데이터 유무 확인
			가져올 객체가 있으면 true
E next()			다음 위치의 데이터로 이동하여 반환


TreeSet
- 이진 탐색 트리 중에서도 성능을 향상시킨 레드블랙트리로 구현되어있다.
- 레드블랙트리는 부모노드보다 작은 값을 가지는 노드는 왼쪽, 큰 값을 가지는 노드는 오른쪽으로 배치한다.
- 데이터의 추가나 삭제시 트리가 한 쪽으로 치우쳐지지 않도록 균형을 맞춰준다.


Map
- List, Set과 달리 Map인터페이스가 별도로 존재하며, 데이터를 List계열 컬렉션과 다르게 처리한다.
- 데이터를 Key와 Value로 구분하여 저장하는 key-value방식을 사용한다.
- index는 없지만 key를 통해서 값을 검색하기 때문에 많은 양의 데이터를 조회하는 데 있어 

HashMap
- map을 구현하고 있는 자식 클래스에서 가장 많이 사용하는 구현체이다.

제네릭 사용시 주의사항
1. 제네릭 타입의 객체는 생성할 수 없다.
- 제네릭 타입 자체로 객체를 생성하는 것은 불가능

T t = new T(); -> X

2. static멤버에 제네릭 타입이 올 수 없음
- static멤버는 클래스가 동일하게 공유하는 변수로서 제네릭 객체가 생성되기도 전에 이미 자료 타입이 정해져 있어야 하기 때문이다.

2-1. static 메서드의 반환타입으로 사용이 불가능

public static T getAge(int n){ -> X
}

2-2. static메서드의 매개변수 타입으로 사용이 불가능하다.

public static void setAge(T age){ -> X
}	

3. 제네릭으로 배열 선언시 주의할 점
- 기본적으로 제네릭 클래스 자체를 배열로 만들 수는 없다.

Studen<Integer>[] arr1 = new Student <>[10]; -> X

제네릭 타입에 클래스가 들어온다는 것은, 클래스끼리 상속을 통해 관계를 맺는 다형성이 그대로 적용되지 않을까??

중첩타입 파라미터
- 제네릭 객체를 제네릭 타입 파라미터로 받는 형식으로 표현할 수 있다.
- ArrayList자체도 하나의 타입으로서 제네릭 타입 파라미터가 될 수 있기 때문에 중첩 형식으로 사용할 수 있다.

제네릭 인터페이스
- 인터페이스를 구현(implements)한 클래스에서도 오버라이딩한 메서드를 제네릭타입에 맞춰서 똑같이 구현해야 한다.

제네릭메서드
메서드에만 적용되는 제네릭타입

Gen클래스를 정의하고 제네릭 타입 T를 갖는 printArr 메서드 생성
- printArr 메서드 내부에서 배열을 순차적으로 출력하는 코드 작성
- GenMain클래스를 작성하고 Integer[], Double[], Character[] 배열을 만든 뒤
Gen클래스의 printArr메서드를 호출하여 각 배열의 내용 출력하기

결과
1 2 3 4 5 
1.1 2.2 3.3 4.4 5.5 
A B C D E


제네릭타입 범위 한정하기
- 제네릭에 타입을 지정해줌으로서 클래스의 타입을 컴파일시에 정하여 타입예외에 대한 안정성을 확보하는 것은 좋지만, 문제는 너무 자유롭다는 점이다.

타입 한정 키워드 extends

<T extends 제한타입>

extends 키워드 뒤에 올 타입은 일반클래스, 추상클래스, 인터페이스 모두 가능하다.

다중타입한정
- 만일 2개 이상의 타입을 동시에 구현한 경우 타입 제한을 하고 싶다면 & 연산자를 사용한다.
- 해당 인터페이스들을 동시에 구현한 클래스가 제네릭 타입에 대상이 되게 한다.
- 단 자바에서는 다중 상속을 지원하지 않기 때문에 클래스로는 다중 extends는 불가능하고 오로지 인터페이스로만 가능하다.

제네릭의 형변환
- 제네릭 형변환
배열과 같은 일반적인 변수 타입과 달리 제네릭 서브 타입간에는 형변환이 불가능하다.
자연스럽게 다형성이 적용될 것이라고 생각할 수 있지만, 실상 제네릭은 전달받은 타입으로만 캐스팅이 가능하다.

제네릭 타입은 상하관계가 없다.
제네릭 타입변수끼리는 아무리 상속 관계에 놓인다 한들 형변환이 불가능하다.

제네릭 와일드카드
제네릭 간의 형변환을 성립되게 하기 위해서는 제네릭에서 제공하는 와일드 카드 문법을 이용해야 한다.

<?> : Unbounded WildCards(제한없음)
- 타입 파라미터를 대치하는 구체적인 타입으로 모든 클래스나 인터페이스 타입이 올 수 있다.

<? extends 상위타입> : Upper Bounded WildCards(상위 클래스 제한)
- 타입 파라미터를 대치하는 구체적인 타입으로 상위 타입이나, 상위 타입의 하위 타입만 올 수 있다.

<? super 하위타입> : Lower Bounded WildCards(하위 클래스 제한)
- 타입 파라미터를 대치하는 구체적인 타입으로 하위 타입이나 하위 타입의 상위 타입만 올 수 있다.

람다식
JDK 1.8부터 함수형 프로그래밍 '람다식(lamda expression)'을 지원한다.
람다식은 이름이 없는 익명함수를 만들기 위한 표현식을 말한다.
자바는 객체를 기반으로 프로그램을 구현하는 객체지향프로그램이다.
클래스를 먼저 생성하고, ㅣ클래스 안에 메서드와 객체를 선언해 사용해야 한다.
하지만 함수형 프로그래밍은 객체 지향 프로그램과 달리 함수만을 구현하고 실행할 수 있는 개발방식이다.

람다식이 도입된 이유
- 함수형 프로그래밍 방식
- 자바에서는함수형 프로그래밍 방식이 적용되지 않았다.
- 자바는 클래스에 함수를 정의하고 객체를 통해 호출하는 방식을 사용하고 있다.

람다식 문법
- 기존의 자바 문법과는 달라서 객체 지향 프로그래밍에 익숙한 개발자들은 다소 생소할 수 있다.
- 하지만 문법이 간결해지고, 원하는 결과를 쉽게 집계할 수 있어 익숙해지면 큰 장점이 있다.

int add(int x, int y){
	return x+y;
}

위 함수를 람다식으로 표현하기
(int x, int y)->{return x+y;}

- 메서드의 이름과 반환형을 제거하고 화살표를 이용해 구현한다.

소괄호 생략하기
- 람다식 문법에서는 파라미터의 자료형을 생략할 수 있다.
(x, y)->{return x+y;}
- 파라미터가 한 개인 경우 소괄호도 생략할 수 있다.
(String str) -> {System.out.println(str);}

(str) -> {System.out.println(str);}
str -> {System.out.println(str);}

중괄호 생략하기
- 함수의 반환형이 void라면 중괄호도 생략할 수 있다.
str -> System.out.println(str);
- 반환형이 있을 때 return 키워드와 중괄호를 같이 생략할 수 있다.
(x,y) -> x + y;

함수형 인터페이스
- 객체지향 프로그램에서 인터페이스를 사용하기 위해서는 구현체를 만든 뒤 사용해야 한다.
- 람다식은 위와 같은 과정을 생략할 수 있다.
- 단, 람다식을 이용해 인터페이스를 사용할 경우, 인터페이스 안에는 하나의 추상메서드만 작성할 수 있다.
- 람다식을 구현하기 위해서는 먼저 인터페이스를 만들고, 인터페이스에 람다식으로 구현할 메서드를 선언해야 한다.
- 오직 하나의 추상 메서드가 선언된 인터페이스만이 람다식의 타겟이 되는데
- 이를 함수형 인터페이스라고 한다.


































